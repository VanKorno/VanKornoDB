package com.vankorno.vankornodb.dbManagement
/** This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 *  If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/

import android.database.sqlite.SQLiteDatabase
import com.vankorno.vankornodb.core.DbConstants.comma
import com.vankorno.vankornodb.core.DbConstants.dbCreateT
import com.vankorno.vankornodb.core.DbConstants.dbDefault
import com.vankorno.vankornodb.dbManagement.TableBuilderUtils.getColumnDefinition
import com.vankorno.vankornodb.dbManagement.TableBuilderUtils.getColumnType
import com.vankorno.vankornodb.dbManagement.data.AutoId
import com.vankorno.vankornodb.dbManagement.data.AutoIdNullable
import com.vankorno.vankornodb.dbManagement.data.BlobCol
import com.vankorno.vankornodb.dbManagement.data.BlobColNullable
import com.vankorno.vankornodb.dbManagement.data.BoolCol
import com.vankorno.vankornodb.dbManagement.data.BoolColNullable
import com.vankorno.vankornodb.dbManagement.data.ColumnDef
import com.vankorno.vankornodb.dbManagement.data.ColumnType
import com.vankorno.vankornodb.dbManagement.data.FloatCol
import com.vankorno.vankornodb.dbManagement.data.FloatColNullable
import com.vankorno.vankornodb.dbManagement.data.IntCol
import com.vankorno.vankornodb.dbManagement.data.IntColNullable
import com.vankorno.vankornodb.dbManagement.data.LongCol
import com.vankorno.vankornodb.dbManagement.data.LongColNullable
import com.vankorno.vankornodb.dbManagement.data.StrCol
import com.vankorno.vankornodb.dbManagement.data.StrColNullable
import com.vankorno.vankornodb.dbManagement.data.TableAndStructure
import com.vankorno.vankornodb.dbManagement.data.TableInfo
import kotlin.collections.forEachIndexed
import kotlin.collections.lastIndex
import kotlin.reflect.KClass
import kotlin.reflect.KClassifier
import kotlin.reflect.KParameter
import kotlin.reflect.full.memberProperties
import kotlin.reflect.full.primaryConstructor


/** For db helper's onCreate 
 * Usage example:
 *     db.createAllTables(
 *         tableOf<DataClass>(TableName),
 *         tableOf<User>(TableUser)
 *     )
 **/


/**
 * Creates a single table in db.
 * Usage: db.createTableOf<EntityDataClass>(tableName)
 */
inline fun <reified T : Any> SQLiteDatabase.createTableOf(tableName: String) = createTables(tableOf<T>(tableName))

/**
 * Creates multiple tables in the database given vararg TableInfo.
 */
fun SQLiteDatabase.createTables(vararg tables: TableInfo) = createTables(tables.toList())

/**
 * Creates multiple tables in the database from a list of TableInfo.
 */
fun SQLiteDatabase.createTables(                                           tables: List<TableInfo>
) {
    tables.forEach { execSQL(it.createQuery()) }
}


/** 
 * Creates a TableInfo instance for a data class and table name.
 * Used to define table schema for creation.
 */
inline fun <reified T : Any> tableOf(name: String): TableInfo = object : TableInfo {
    override val name = name
    override fun createQuery() = newTableQuery<T>(name)
}




/**
 * Generates a SQL CREATE TABLE statement for the given [tableName] based on the structure of
 * the data class [T].
 *
 * The class [T] must have a primary constructor, and all parameters must have default values.
 *
 * Fields ending with "List" and declared as List<T> are expanded into multiple columns,
 * one per element in the default list. The column names are generated by removing the "List"
 * suffix and appending a 1-based index (e.g., `tagList: List<String> = listOf("a", "b")` produces
 * `tag1`, `tag2`).
 *
 * Default values for fields (when possible) are included in the column definitions.
 * Null values and unsupported types (e.g., arrays or empty lists) are skipped.
 *
 * @param tableName The name of the table to create.
 * @return The full SQL CREATE TABLE string.
 */

inline fun <reified T : Any> newTableQuery(                                    tableName: String
): String {
    val constructor = T::class.primaryConstructor
        ?: error("Class ${T::class.simpleName} must have a primary constructor")
    
    val defaultsInstance = constructor.callBy(emptyMap())
    val columns = mutableListOf<String>()
    
    constructor.parameters.forEach { param ->
        val name = param.name ?: return@forEach
        val classifier = param.type.classifier
        
        // Handle List<T> fields
        if (name.endsWith("List") && classifier == List::class) {
            val property = T::class.memberProperties.firstOrNull { it.name == name } ?: return@forEach
            
            val value = property.getter.call(defaultsInstance)
            
            val list = value as? List<*> ?: return@forEach
            if (list.isEmpty()) return@forEach
            
            val elementType = param.type.arguments.firstOrNull()?.type?.classifier as? KClass<*>
                ?: error("Cannot determine element type for $name")
            
            val defaultValue = list.first()
            val columnType = getColumnType(name, elementType, isNullable = false)
                ?: error("Unsupported element type $elementType for list field $name")

            val defaultSqlValue = when (defaultValue) {
                is String -> "'$defaultValue'"
                is Boolean -> if (defaultValue) "1" else "0"
                is ByteArray -> null // skip default for blobs
                null -> null // treat null same as no default
                else -> defaultValue.toString()
            }
            
            val defaultClause = defaultSqlValue?.let { dbDefault + it } ?: ""
            
            list.indices.forEach { idx ->
                val colName = name.removeSuffix("List") + (idx + 1)
                val colDef = colName + columnType.sql + defaultClause
                columns += colDef
            }
        } else { // Normal field
            val col = getColumnDefinition(param, defaultsInstance)
            if (col != null) columns += col
        }
    }
    val queryStr = dbCreateT + tableName + " (" + columns.joinToString(", ") + ")"
    // region LOG
        println("newTableQuery<${T::class.simpleName}>(): $queryStr")
    // endregion
    return queryStr
}



object TableBuilderUtils {
    /**
    * Maps a Kotlin type to an internal SQL column type, considering nullability and field name.
    * Special case: if the field is named "id", it's treated as an auto-increment primary key.
    * Returns null for unsupported types.
    */
    fun getColumnType(                                                     paramName: String?,
                                                                          classifier: KClassifier?,
                                                                          isNullable: Boolean
    ): ColumnType? {
        if (paramName == null) return null
    
        return when (classifier) {
            Int::class ->       if (paramName == "id") {
                                    if (isNullable) AutoIdNullable else AutoId
                                } else {
                                    if (isNullable) IntColNullable else IntCol
                                }
            String::class ->    if (isNullable) StrColNullable else StrCol
            Boolean::class ->   if (isNullable) BoolColNullable else BoolCol
            Long::class ->      if (isNullable) LongColNullable else LongCol
            Float::class ->     if (isNullable) FloatColNullable else FloatCol
            ByteArray::class -> if (isNullable) BlobColNullable else BlobCol
            else -> null // unsupported types like List, Array, etc.
        }
    }
    
    inline fun <reified T : Any> getColumnDefinition(                            param: KParameter,
                                                                      defaultsInstance: T
    ): String? {
        val name = param.name ?: return null
        val classifier = param.type.classifier
        val isNullable = param.type.isMarkedNullable
        
        val colType = getColumnType(name, classifier, isNullable) ?: return null
        
        val defaultValue = T::class.memberProperties
                                .firstOrNull { it.name == name }?.getter?.call(defaultsInstance)
        
        // SKIP default clause for AutoId/AutoIdNullable or null default
        val skipDefault = colType == AutoId || colType == AutoIdNullable || defaultValue == null
        
        val defaultClause = if (!isNullable  &&  !skipDefault) {
            val defaultSqlValue = when (defaultValue) {
                is String -> "'$defaultValue'"
                is Boolean -> if (defaultValue) "1" else "0"
                is ByteArray -> null // skip default for blobs
                else -> defaultValue.toString()
            }
            if (defaultSqlValue != null) dbDefault + defaultSqlValue else ""
        } else ""
        
        return name + colType.sql + defaultClause
    }
}






